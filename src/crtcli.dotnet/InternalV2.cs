using System.Text.Json;
using CrtCli.Dotnet.Context;
using CrtCli.Dotnet.Database;
using CrtCli.Dotnet.Mocking;
using CrtCli.Dotnet.Mocking.Core.Packages;
using CrtCli.Dotnet.Mocking.Extensions;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Terrasoft.Common;
using Terrasoft.Core;

namespace CrtCli.Dotnet;

internal static class InternalV2
{
    public static void InternalMain(string packageDir)
    {
        MockingExtensions.InitializeGlobalAppSettingsDefaults();
        
        var serviceProvider = CreateServiceProvider();
        // TODO: scope?

        CoreApiContainerExtensions.Initialize(serviceProvider);

        var packageContextAccessor = serviceProvider.GetRequiredService<PackageContextAccessor>();
        
        packageContextAccessor.SetPackageContext(new PackageContext(packageDir));
        
        var packageContext = serviceProvider.GetRequiredService<IPackageContext>();
        
        var logger = serviceProvider.GetRequiredService<ILogger<Program>>();
                
        var destinationFolder =  Path.Combine("Autogenerated", "Src");
        var generatedFileNames = new HashSet<string>();

        foreach (var schemaContext in packageContext.Schemas)
        {
            if (schemaContext.Descriptor.ManagerName is not ("ProcessSchemaManager" or "ProcessUserTaskSchemaManager"))
            {
                continue;
            }
            
            // Console.WriteLine($"{schemaContext.BasePath}/metadata.json");

            var userConnection = serviceProvider.GetRequiredService<UserConnection>();
            var schemaManager = userConnection.GetSchemaManager(schemaContext.Descriptor.ManagerName);
                
            // DbCommandMock.CurrentMetadataUId = descriptor.Descriptor.UId;
            // DbCommandMock.CurrentMetadata = File.ReadAllBytes($"{schemaDir}/metadata.json");
                
            var sources = schemaManager.GetSchemaSources(
                schemaContext.Descriptor.UId,
                schemaContext.Descriptor.UId, // schemaId
                userConnection,
                out var error);

            if (error.IsNotNullOrEmpty())
            {
                throw new Exception(error);
            }

            foreach (var entity in sources)
            {
                var source = entity.GetStreamValue("Source");
                var filename = entity.GetTypedColumnValue<string>("Name");

                filename = $"{Path.GetFileNameWithoutExtension(filename)}.{packageContext.Descriptor.Name}{Path.GetExtension(filename)}";

                generatedFileNames.Add(filename);
                    
                var relativePath = Path.Combine(destinationFolder, filename);
                var absolutePath = Path.Combine(packageDir, relativePath);
                var relativePathStr = $".{Path.DirectorySeparatorChar}{relativePath}";
                    
                using var sr = new StreamReader(source);
                var sourceCode = sr.ReadToEnd();
                    
                Directory.CreateDirectory(Path.GetDirectoryName(absolutePath)!);
                    
                if (File.Exists(absolutePath))
                {
                    var existingContent = File.ReadAllText(absolutePath);
                    if (existingContent != sourceCode)
                    {
                        File.WriteAllText(absolutePath, sourceCode);
                        logger.LogInformation("{RelativePath} modified", relativePathStr);
                    }
                    else
                    {
                        logger.LogInformation("{RelativePath} not changed", relativePathStr);
                    }
                }
                else
                {
                    File.WriteAllText(absolutePath, sourceCode);
                    logger.LogInformation("{RelativePath} created", relativePathStr);
                }
            }
        }

        // Delete files that exist in the destination folder but aren't in generatedFileNames
        var destinationDir = Path.Combine(packageDir, destinationFolder);
        if (Directory.Exists(destinationDir))
        {
            var allowedFiles = new HashSet<string>(generatedFileNames, StringComparer.OrdinalIgnoreCase);
            var existingFiles = Directory.GetFiles(destinationDir, "*", SearchOption.AllDirectories);
                    
            foreach (var existingFile in existingFiles)
            {
                var relativePath = Path.GetRelativePath(destinationDir, existingFile);
                if (!allowedFiles.Contains(relativePath))
                {
                    File.Delete(existingFile);
                    logger.LogInformation("{RelativePath} deleted", $".{Path.DirectorySeparatorChar}{Path.Combine(destinationFolder, relativePath)}");
                            
                    // Remove empty parent directories
                    var dir = Path.GetDirectoryName(existingFile);
                    while (!string.IsNullOrEmpty(dir) && 
                           dir.StartsWith(destinationDir, StringComparison.OrdinalIgnoreCase) &&
                           Directory.Exists(dir) && 
                           !Directory.EnumerateFileSystemEntries(dir).Any())
                    {
                        Directory.Delete(dir);
                        dir = Path.GetDirectoryName(dir);
                    }
                }
            }
        }
    }


    static void ConfigureLogging(ILoggingBuilder configure)
    {
        configure.AddSimpleConsole(options =>
        {
            options.SingleLine = true;
        });
    }
    
    private static IServiceProvider CreateServiceProvider()
    {
        var services = new ServiceCollection();
        
        services.AddCrtCliDotnetMocking();

        services.AddLogging(ConfigureLogging); //TODO
        
        services.AddTransient<IPackageTypeProviderMock, PackageContextPackageTypeProviderMock>();
        
        services.AddDatabaseMocking();

        services.AddScoped<PackageContextAccessor>();
        
        services.AddTransient<IPackageContextAccessor, PackageContextAccessor>(
            sp => sp.GetRequiredService<PackageContextAccessor>());
        
        services.AddTransient<IPackageContext>(
            sp => sp.GetRequiredService<IPackageContextAccessor>().PackageContext);
        
        return services.BuildServiceProvider();
    }
}